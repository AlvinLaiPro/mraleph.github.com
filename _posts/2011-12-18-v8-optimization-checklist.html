---
layout: blogpost
title: I-want-to-optimize-my-JS-application-on-V8 checklist
date: 2011-12-18
---

<p>Samurais had something called <em>bushid&#333;</em>, way of the warrior, code of conduct they had to follow. In similar manner you have to follow certain <em>opt-d&#333;</em> if you want to optimize your application. I have tried to sketch such a path in my nodecamp.eu talk "<a href="http://s3.mrale.ph/nodecamp.eu/#1">Understanding V8</a>" and <a href="https://plus.google.com/111909581069462963574">+Daniel Clifford</a> tried to do the same in "<a href="https://mkw.st/p/gdd11-berlin-v8-performance-tuning-tricks/#1">V8 Performance Tuning Tricks</a>" talk on GDD11 in Berlin. But not everybody has seen those talks and the question keeps coming back again. So I decided to write down a quick check list for developers who want to optimize their apps. tl;dr version of my checklist is: "<em>Understand before you act</em>".&nbsp;</p>
<p><a id="talks-and-posts" name="talks-and-posts"></a></p>
<h2>Understanding V8 and&nbsp;beyond&nbsp;[talks and posts]</h2>

<p>I am maintaining a list of V8 related resources. <a href="/v8/resources.html">See it here</a></p>

<h2>Do you understand what the application is trying to do and how?</h2>
<p>The more you understand about your app the better you can optimize it. Sometimes a tricky algorithm or a cache placed in right place will yield more improvements than any local tweaking. Understanding your application in large is a very difficult problem which requires special tooling and discipline. I highly recommend to read <a href="https://twitter.com/#!/coda">@coda</a>'s <a href="http://codahale.com/codeconf-2011-04-09-metrics-metrics-everywhere.pdf">Metrics Metrics Everywhere</a> talk if you want to get a glimpse of that world. Sometimes it is possible to split big application into pieces and optimize them separately but there is no guarantee that overall gain will not be lost when those pieces are connected back together.</p>
<h2>Did you profile your application with built in statistical profiler?</h2>
<p>Profiling helps to discover obvious hot spots. Don't waste time rewriting places that occupy 0.0001% of running time. Concentrate your efforts on those that are high on the profile. If you are using V8's tick processors keep in mind that <code>LazyCompile: </code> prefix does <strong>not</strong> mean that this time was spent in compiler, it just means that the function itself was compiled lazily. Statistical profiler is not the most accurate tool in the world and might miss overheads that are finely spread across execution (as sampling interval is 2ms). Tools like dtrace, perf, Instruments, VTune might provide a more fine grained picture but they do not necessarily have support for JITed code (see below).</p>
<h3>JavaScript function is high on the profile</h3>
<p>Ensure that this function is optimized and Crankshaft friendly. V8's tick processing scripts mark optimized functions with <code>*</code> (asterisk) and non-optimized with <code>~</code> (tilda). You can also use <code>--trace-opt --trace-deopt</code> flags to see what Crankshaft does with your program. Deoptimizations happen when assumptions made by the compiler does not match program's runtime behavior, bailouts happens when compiler can't compile the function with optimizations for some reason. [note that in V8 prior to version 3.13.4 you'll need to supply <code>--trace-bailout</code> to see optimizing compiler bailouts] If you want to understand ideas behind V8 optimization pipeline I recommend to start by reading Andy Wingo's <a href="http://wingolog.org/archives/2011/07/05/v8-a-tale-of-two-compilers">A Tale of Two Compilers</a> post.</p>
<p>In general it's a good idea to know more about modern JavaScript VMs, especially their strengths and weaknesses. I recommend going through&nbsp;<a href="http://twitter.com/dmandelin">David Mandelin</a>'s talk&nbsp;<a href="http://people.mozilla.com/~dmandelin/KnowYourEngines_Velocity2011.pdf">Know Your Engines</a>. This talk stresses a very important aspect of modern JS performance: fastest application is the one that is essentially&nbsp;statically&nbsp;typed in it's nature.</p>
<p>Modern JavaScript VMs try to grasp "static" structure hidden inside dynamic JS code by utilizing <em>hidden classes</em> and <em>inline caches</em>. Take a look at <a href="http://s3.mrale.ph/nodecamp.eu/#41">my slide deck</a>&nbsp;to get a basic understanding of how those hidden classes are built and used.&nbsp;&nbsp;</p>
<p>For V8 it is also important to check how you store floating point numbers (and integers that exceed 31-bit range in case of ia32 version of v8) and use WebGL typed arrays if appropriate. These days V8 tries to adapt generic arrays' storage to the data you store in them, but understanding whether those optimizations kicked in or not might be difficult; thus I just recommend using typed arrays.</p>
<h3>GC is high on the profile</h3>
<p>Try to understand what your are allocating and (more important) what survives several GCs. The worst kind of object is the one that survives a couple of partial (aka scavenge) collections and then gets thrown away. This kind of workload is the most stressful for GC because it has to copy young objects around constantly. Objects that live long are less stressful (but you have to keep in mind that GC cost is proportional to the number of live objects). The best kind of object is the one that dies shortly after it's allocation. You can use <code>--trace-gc</code> to see GC pauses and you can use built in heap snapshots to figure out what takes space in your heap. [it might be hard or impossible to capture "middle-aged" garbage with heap snapshots because V8 does full garbage collection before taking snapshot thus effectively killing all such garbage].</p>
<h3>JS natives are high on the profile</h3>
<p>When I say _natives_ I mean built in methods of <code>String</code>/<code>Number</code>/<code>Boolean</code>/<code>RegExp</code>/<code>JSON</code> and global functions like <code>parseInt</code> etc. Here you can't optimize anything directly but you can try to figure out two things:</p>
<ul>
<li><strong>Try calling them less by changing your algorithms and/or fusing them into it.</strong> Some of those methods are very generic (e.g. forEach). Some can be fused with your functions (e.g. you have to parse integer contained in some stream: you can either build a temporary string character by character and pass it to parseInt or you can fuse parsing and reading from a stream; later is better)</li>
<li><strong>Is there some obvious performance problem with them?</strong> V8's implementation of the native method can be suboptimal. If you see a bug (or you suspect that it can be improved) please <a href="http://code.google.com/p/v8/issues/entry">file a bug</a> or write a question to <a href="https://groups.google.com/group/v8-users">v8-users</a> mailing list.</li>
</ul>
<h3>Some strange V8 internals are high on the profile</h3>
<p>In this case you can either read V8's source or send a question to&nbsp;<a href="https://groups.google.com/group/v8-users">v8-users</a> list.</p>
<h3>A lot of time is spent in your C++ code</h3>
<p>Sorry this is out of scope. Consult C++ optimization guides :-)</p>
<h2>Do you feel that V8's statistical profiler misses hotspot?</h2>
<p>Your best bet then is either hardware counters based tool like Linux <code>perf</code> for which V8 has support (see <code>v8/tools/ll_prof.py --help</code> for more details) or trying to spot&nbsp;anomalies&nbsp;by some sort of software counters based profiling. V8 has it's own simple software counters subsystem (try passing <code>--native-code-counters --dump-counters</code> to <code>d8</code> shell).</p>
<h2>Do you want to go deeper?</h2>
<p>If you feel that generated code is slow and you can improve it you should definitely check it out using flags <code>--print-code --code-comments</code>. You can also dump IR used by optimizing compiler with <code>--trace-hydrogen</code>. IR will be written into <code>hydrogen.cfg</code> file that can be viewed by <a href="http://java.net/projects/c1visualizer/">C1 Visualizer</a>.</p>
<h2>Are you still lost?</h2>
<p>Drop a line to <a href="mailto:me@mrale.ph">me</a> or better to <a href="https://groups.google.com/group/v8-users">v8-users</a> mailing list. Try your best to provide as much context as possible (a standalone JS benchmark is the best way). It's nearly impossible to diagnose performance problems based on vague descriptions of what you are trying to achieve and how slow it runs.</p>
<blockquote><em>There is something to be learned from a rainstorm. When meeting with a sudden shower, you try not to get wet and run quickly along the road. But doing such things as passing under the eaves of houses, you still get wet. When you are resolved from the beginning, you will not be perplexed, though you still get the same soaking</em><br />&mdash; <a href="http://en.wikipedia.org/wiki/Hagakure">Hagakure</a> by&nbsp;<a href="http://en.wikipedia.org/wiki/Yamamoto_Tsunetomo" title="Yamamoto Tsunetomo">Yamamoto Tsunetomo.</a></blockquote>
<p>Similarly you have to be resolved from the beginning when you want to optimize your app. Randomly tweaking things in panic here and there does not help.</p>
<p>Understand before you act.</p>
